------- FILE iceMountain.asm LEVEL 1 PASS 2
      1  fffe					      processor	6502
      2  10000 ????
      3  10000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      4  10000 ????						;; Include required files with the VCS memory mapping and macros
      5  10000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      6  10000 ????
------- FILE vcs.h LEVEL 2 PASS 2
      0  10000 ????				       include	"vcs.h"
      1  10000 ????						; VCS.H
      2  10000 ????						; Version 1.05, 13/November/2003
      3  10000 ????
      4  10000 ????		00 69	    VERSION_VCS =	105
      5  10000 ????
      6  10000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      7  10000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  10000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
      9  10000 ????						;
     10  10000 ????						; This file defines hardware registers and memory mapping for the
     11  10000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     12  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  10000 ????						; available at at http://www.atari2600.org/dasm
     14  10000 ????						;
     15  10000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     16  10000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     17  10000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     18  10000 ????						; with your views.  Please contribute, if you think you can improve this
     19  10000 ????						; file!
     20  10000 ????						;
     21  10000 ????						; Latest Revisions...
     22  10000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     23  10000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     24  10000 ????						;			    This will allow conditional code to verify VCS.H being
     25  10000 ????						;			    used for code assembly.
     26  10000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     27  10000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     28  10000 ????						;			 mirrored reading/writing differences.	This is more a 
     29  10000 ????						;			 readability issue, and binary compatibility with disassembled
     30  10000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     31  10000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     32  10000 ????						;			 which was broken by the use of segments in this file, as
     33  10000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     34  10000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     35  10000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     36  10000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     37  10000 ????						;						   it is safe to leave it undefined, and the base address will
     38  10000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     39  10000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     40  10000 ????						;			  - register definitions are now generated through assignment
     41  10000 ????						;			    in uninitialised segments.	This allows a changeable base
     42  10000 ????						;			    address architecture.
     43  10000 ????						; 1.0	22/MAR/2003		Initial release
     44  10000 ????
     45  10000 ????
     46  10000 ????						;-------------------------------------------------------------------------------
     47  10000 ????
     48  10000 ????						; TIA_BASE_ADDRESS
     49  10000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     50  10000 ????						; Normally 0, the base address should (externally, before including this file)
     51  10000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     52  10000 ????						; The reason is that this bankswitching scheme treats any access to locations
     53  10000 ????						; < $40 as a bankswitch.
     54  10000 ????
     55  10000 ????			   -	       IFNCONST	TIA_BASE_ADDRESS
     56  10000 ????			   -TIA_BASE_ADDRESS =	0
     57  10000 ????				       ENDIF
     58  10000 ????
     59  10000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     60  10000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     61  10000 ????						; *OR* by declaring the label before including this file, eg:
     62  10000 ????						; TIA_BASE_ADDRESS = $40
     63  10000 ????						;   include "vcs.h"
     64  10000 ????
     65  10000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     66  10000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     67  10000 ????						; for the mirrored ROM hardware registers.
     68  10000 ????
     69  10000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     70  10000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     71  10000 ????						; they defaut to the TIA_BASE_ADDRESS.
     72  10000 ????
     73  10000 ????			   -	       IFNCONST	TIA_BASE_READ_ADDRESS
     74  10000 ????			   -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     75  10000 ????				       ENDIF
     76  10000 ????
     77  10000 ????			   -	       IFNCONST	TIA_BASE_WRITE_ADDRESS
     78  10000 ????			   -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     79  10000 ????				       ENDIF
     80  10000 ????
     81  10000 ????						;-------------------------------------------------------------------------------
     82  10000 ????
     83 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     84 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     85 U0000
     86 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     87 U0000
     88 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     89 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     90 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     91 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     92 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     93 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     94 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     95 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     96 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     97 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     98 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     99 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    100 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    101 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    102 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    103 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    104 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    105 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    106 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    107 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    108 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    109 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    110 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    111 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    112 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    113 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    114 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    115 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    116 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    117 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    118 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    119 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    120 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    121 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    122 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    123 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    124 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    125 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    126 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    127 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    128 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    129 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    130 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    131 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    132 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    133 U002d
    134 U002d							;-------------------------------------------------------------------------------
    135 U002d
    136 U000e ????				      SEG.U	TIA_REGISTERS_READ
    137 U0000					      ORG	TIA_BASE_READ_ADDRESS
    138 U0000
    139 U0000							;											bit 7	 bit 6
    140 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    141 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    142 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    143 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    144 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    145 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    146 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    147 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    148 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    149 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    150 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    151 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    152 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    153 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    154 U000e
    155 U000e							;-------------------------------------------------------------------------------
    156 U000e
    157 U0298 ????				      SEG.U	RIOT
    158 U0280					      ORG	$280
    159 U0280
    160 U0280							; RIOT MEMORY MAP
    161 U0280
    162 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    163 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    164 U0281
    165 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    166 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    167 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    168 U0284		       00	   INTIM      ds	1	; $284		Timer output
    169 U0285
    170 U0285		       00	   TIMINT     ds	1	; $285
    171 U0286
    172 U0286							; Unused/undefined registers ($285-$294)
    173 U0286
    174 U0286		       00		      ds	1	; $286
    175 U0287		       00		      ds	1	; $287
    176 U0288		       00		      ds	1	; $288
    177 U0289		       00		      ds	1	; $289
    178 U028a		       00		      ds	1	; $28A
    179 U028b		       00		      ds	1	; $28B
    180 U028c		       00		      ds	1	; $28C
    181 U028d		       00		      ds	1	; $28D
    182 U028e		       00		      ds	1	; $28E
    183 U028f		       00		      ds	1	; $28F
    184 U0290		       00		      ds	1	; $290
    185 U0291		       00		      ds	1	; $291
    186 U0292		       00		      ds	1	; $292
    187 U0293		       00		      ds	1	; $293
    188 U0294
    189 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    190 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    191 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    192 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    193 U0298
    194 U0298							;-------------------------------------------------------------------------------
    195 U0298							; The following required for back-compatibility with code which does not use
    196 U0298							; segments.
    197 U0298
    198  0000 ????				      SEG
    199  0000 ????
    200  0000 ????						; EOF
------- FILE iceMountain.asm
------- FILE macro.h LEVEL 2 PASS 2
      0  0000 ????				      include	"macro.h"
      1  0000 ????						; MACRO.H
      2  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      3  0000 ????
      4  0000 ????	       00 6a	   VERSION_MACRO =	106
      5  0000 ????
      6  0000 ????						;
      7  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
      9  0000 ????						;
     10  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     11  0000 ????						; It is distributed as a companion machine-specific support package
     12  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  0000 ????						; available at at http://www.atari2600.org/dasm
     14  0000 ????						;
     15  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     16  0000 ????						; contents, or would like to add something, please write to me
     17  0000 ????						; (atari2600@taswegian.com) with your contribution.
     18  0000 ????						;
     19  0000 ????						; Latest Revisions...
     20  0000 ????						;
     21  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     22  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     23  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     24  0000 ????						;			   used for code assembly.
     25  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     26  0000 ????						;
     27  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     28  0000 ????						;
     29  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     30  0000 ????						;			   (standardised macro for vertical synch code)
     31  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     32  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     33  0000 ????						; 1.0	22/MAR/2003		Initial release
     34  0000 ????
     35  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     36  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     37  0000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     38  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     39  0000 ????						;   registers and require them to be defined first).
     40  0000 ????
     41  0000 ????						; Available macros...
     42  0000 ????						;   SLEEP n		 - sleep for n cycles
     43  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     44  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     45  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     46  0000 ????
     47  0000 ????						;-------------------------------------------------------------------------------
     48  0000 ????						; SLEEP duration
     49  0000 ????						; Original author: Thomas Jentzsch
     50  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     51  0000 ????						; useful for code where precise timing is required.
     52  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     53  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     54  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     55  0000 ????
     56  0000 ????				      MAC	sleep
     57  0000 ????			   .CYCLES    SET	{1}
     58  0000 ????
     59  0000 ????				      IF	.CYCLES < 2
     60  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     61  0000 ????				      ERR
     62  0000 ????				      ENDIF
     63  0000 ????
     64  0000 ????				      IF	.CYCLES & 1
     65  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     66  0000 ????				      nop	0
     67  0000 ????				      ELSE
     68  0000 ????				      bit	VSYNC
     69  0000 ????				      ENDIF
     70  0000 ????			   .CYCLES    SET	.CYCLES - 3
     71  0000 ????				      ENDIF
     72  0000 ????
     73  0000 ????				      REPEAT	.CYCLES / 2
     74  0000 ????				      nop
     75  0000 ????				      REPEND
     76  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     77  0000 ????
     78  0000 ????						;-------------------------------------------------------------------------------
     79  0000 ????						; VERTICAL_SYNC
     80  0000 ????						; revised version by Edwin Blink -- saves bytes!
     81  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     82  0000 ????						; Note: Alters the accumulator
     83  0000 ????
     84  0000 ????						; OUT: A = 0
     85  0000 ????
     86  0000 ????				      MAC	vertical_sync
     87  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     88  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     89  0000 ????				      sta	VSYNC
     90  0000 ????				      lsr
     91  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     92  0000 ????				      ENDM
     93  0000 ????
     94  0000 ????						;-------------------------------------------------------------------------------
     95  0000 ????						; CLEAN_START
     96  0000 ????						; Original author: Andrew Davie
     97  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     98  0000 ????						; Sets stack pointer to $FF, and all registers to 0
     99  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    100  0000 ????						; Use as very first section of code on boot (ie: at reset)
    101  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    102  0000 ????
    103  0000 ????				      MAC	clean_start
    104  0000 ????				      sei
    105  0000 ????				      cld
    106  0000 ????
    107  0000 ????				      ldx	#0
    108  0000 ????				      txa
    109  0000 ????				      tay
    110  0000 ????			   .CLEAR_STACK dex
    111  0000 ????				      txs
    112  0000 ????				      pha
    113  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    114  0000 ????
    115  0000 ????				      ENDM
    116  0000 ????
    117  0000 ????						;-------------------------------------------------------
    118  0000 ????						; SET_POINTER
    119  0000 ????						; Original author: Manuel Rotschkar
    120  0000 ????						;
    121  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    122  0000 ????						;
    123  0000 ????						; Usage: SET_POINTER pointer, address
    124  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    125  0000 ????						;
    126  0000 ????						; Note: Alters the accumulator, NZ flags
    127  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    128  0000 ????						; IN 2: absolute address
    129  0000 ????
    130  0000 ????				      MAC	set_pointer
    131  0000 ????			   .POINTER   SET	{1}
    132  0000 ????			   .ADDRESS   SET	{2}
    133  0000 ????
    134  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    135  0000 ????				      STA	.POINTER	; Store in pointer
    136  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    137  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    138  0000 ????
    139  0000 ????				      ENDM
    140  0000 ????
    141  0000 ????						;-------------------------------------------------------
    142  0000 ????						; BOUNDARY byte#
    143  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    144  0000 ????						;
    145  0000 ????						; Push data to a certain position inside a page and keep count of how
    146  0000 ????						; many free bytes the programmer will have.
    147  0000 ????						;
    148  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    149  0000 ????
    150  0000 ????			   .FREE_BYTES SET	0
    151  0000 ????				      MAC	boundary
    152  0000 ????				      REPEAT	256
    153  0000 ????				      IF	<. % {1} = 0
    154  0000 ????				      MEXIT
    155  0000 ????				      ELSE
    156  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    157  0000 ????				      .byte	$00
    158  0000 ????				      ENDIF
    159  0000 ????				      REPEND
    160  0000 ????				      ENDM
    161  0000 ????
    162  0000 ????
    163  0000 ????						; EOF
------- FILE iceMountain.asm
      9  0000 ????
     10  0000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     11  0000 ????						;; Declare the variables from address $80
     12  0000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     13  0000 ????
     14 U0096 ????				      seg.u	Variables
     15 U0080					      org	$80
     16 U0080
     17 U0080		       00	   SnowmanX   byte.b		; Player 0 (snowman) X axis position
     18 U0081		       00	   SnowmanY   byte.b		; Player 0 (snowman) Y axis position
     19 U0082		       00	   IcicleX    byte.b		; Player 1 (icicle) X axis position
     20 U0083		       00	   IcicleY    byte.b		; Player 1 (icicle) Y axis position
     21 U0084		       00	   SnowmanOffsetL byte.b		; Player 0 (snowman) offset for left sprite
     22 U0085		       00	   SnowmanOffsetR byte.b		; Player 0 (snowman) offset for right sprite
     23 U0086		       00	   Random     byte.b		; random number for setting player 1 X pos
     24 U0087		       00	   Score      byte.b		; stores the value for the score
     25 U0088		       00	   Temp       byte.b		; variable to store temporary time values
     26 U0089		       00	   TimerSprite byte.b		; stores the current time sprite
     27 U008a		       00 00	   OnesDigit  word.w		; stores offset of ones digit
     28 U008c		       00 00	   TensDigit  word.w		; stores offset of tens digit
     29 U008e		       00 00	   SnowmanColPtr word.w		; Player 0 (nowman) color pointer
     30 U0090		       00 00	   SnowmanPtr word.w		; Player 0 (snowman) pointer
     31 U0092		       00 00	   IcicleColPtr word.w		; player 1 (icicle) color pointer
     32 U0094		       00 00	   IciclePtr  word.w		; Player 1 (icicle) pointer
     33 U0096
     34 U0096
     35 U0096							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     36 U0096							;; Define Constants
     37 U0096							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     38 U0096
     39 U0096		       00 0a	   SNOWMAN_H  =	10	; Height for snowman sprite
     40 U0096		       00 14	   SNOWMAN_H_X2 =	20	; Height for two snowmen for right animation
     41 U0096		       00 0a	   ICICLE_H   =	10	; Height for icicle sprite
     42 U0096		       00 05	   DIGITS_H   =	5	; Height for timer
     43 U0096
     44 U0096							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     45 U0096							;; Start the ROM at address $F000
     46 U0096							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     47 U0096
     48  10000 ????				       seg	Code
     49  f000					      org	$F000
     50  f000
     51  f000				   Reset
      0  f000					      CLEAN_START		; Calls macro to clear memory / registers
      1  f000		       78		      sei
      2  f001		       d8		      cld
      3  f002
      4  f002		       a2 00		      ldx	#0
      5  f004		       8a		      txa
      6  f005		       a8		      tay
      7  f006		       ca	   .CLEAR_STACK dex
      8  f007		       9a		      txs
      9  f008		       48		      pha
     10  f009		       d0 fb		      bne	.CLEAR_STACK
     11  f00b
     53  f00b
     54  f00b							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     55  f00b							;; Initialize RAM vars and TIA registers
     56  f00b							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     57  f00b
     58  f00b		       a9 01		      lda	#1
     59  f00d		       85 81		      sta	SnowmanY	; SnowmanY = 1
     60  f00f
     61  f00f		       a9 28		      lda	#40
     62  f011		       85 80		      sta	SnowmanX	; SnowmanX = 40
     63  f013
     64  f013		       a9 49		      lda	#73
     65  f015		       85 83		      sta	IcicleY	; IcicleY = 73
     66  f017
     67  f017		       a9 32		      lda	#50
     68  f019		       85 82		      sta	IcicleX	; IcicleX = 50
     69  f01b
     70  f01b		       a9 d4		      lda	#%11010100
     71  f01d		       85 86		      sta	Random	; Sets Random seed
     72  f01f
     73  f01f		       a9 04		      lda	#4
     74  f021		       85 87		      sta	Score
     75  f023
     76  f023
     77  f023							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     78  f023							;; Initilize sprite and color pointers
     79  f023							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     80  f023
     81  f023		       a9 be		      lda	#<SnowmanColor
     82  f025		       85 8e		      sta	SnowmanColPtr	; Low-byte pointer for snowman color bitmap
     83  f027		       a9 f2		      lda	#>SnowmanColor
     84  f029		       85 8f		      sta	SnowmanColPtr+1	; High-byte pointer for snowman color bitmap
     85  f02b
     86  f02b		       a9 dc		      lda	#<IcicleColor
     87  f02d		       85 92		      sta	IcicleColPtr	; Low-byte pointer for icicle color bitmap
     88  f02f		       a9 f2		      lda	#>IcicleColor
     89  f031		       85 93		      sta	IcicleColPtr+1	; High-byte pointer for icicle color bitmap
     90  f033
     91  f033		       a9 e6		      lda	#<Snowman
     92  f035		       85 90		      sta	SnowmanPtr	; Low-byte pointer for snowman bitmap
     93  f037		       a9 f2		      lda	#>Snowman
     94  f039		       85 91		      sta	SnowmanPtr+1	; High-byte pointer for snowman bitmap
     95  f03b
     96  f03b		       a9 04		      lda	#<Icicle
     97  f03d		       85 94		      sta	IciclePtr	; Low-byte pointer for icicle bitmap
     98  f03f		       a9 f3		      lda	#>Icicle
     99  f041		       85 95		      sta	IciclePtr+1	; High-byte pointer for icicle bitmap
    100  f043
    101  f043							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    102  f043							;; Start the main game display and render frames
    103  f043							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    104  f043
    105  f043				   StartFrame
    106  f043
    107  f043							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    108  f043							;; Display VSYNC and VBLANK
    109  f043							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    110  f043
    111  f043		       a9 02		      lda	#2	;
    112  f045		       85 01		      sta	VBLANK	; turns on VBLANK
    113  f047		       85 00		      sta	VSYNC	; turns on VSYNC
    114  f049					      REPEAT	3
    115  f049		       85 02		      sta	WSYNC	; display 3 lines of VSYNC
    114  f049					      REPEND
    115  f04b		       85 02		      sta	WSYNC	; display 3 lines of VSYNC
    114  f04b					      REPEND
    115  f04d		       85 02		      sta	WSYNC	; display 3 lines of VSYNC
    116  f04f					      REPEND
    117  f04f		       a9 00		      lda	#0
    118  f051		       85 00		      sta	VSYNC	; turns off VSYNC
    119  f053
    120  f053					      REPEAT	33
    121  f053		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f053					      REPEND
    121  f055		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f055					      REPEND
    121  f057		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f057					      REPEND
    121  f059		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f059					      REPEND
    121  f05b		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f05b					      REPEND
    121  f05d		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f05d					      REPEND
    121  f05f		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f05f					      REPEND
    121  f061		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f061					      REPEND
    121  f063		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f063					      REPEND
    121  f065		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f065					      REPEND
    121  f067		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f067					      REPEND
    121  f069		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f069					      REPEND
    121  f06b		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f06b					      REPEND
    121  f06d		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f06d					      REPEND
    121  f06f		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f06f					      REPEND
    121  f071		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f071					      REPEND
    121  f073		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f073					      REPEND
    121  f075		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f075					      REPEND
    121  f077		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f077					      REPEND
    121  f079		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f079					      REPEND
    121  f07b		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f07b					      REPEND
    121  f07d		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f07d					      REPEND
    121  f07f		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f07f					      REPEND
    121  f081		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f081					      REPEND
    121  f083		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f083					      REPEND
    121  f085		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f085					      REPEND
    121  f087		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f087					      REPEND
    121  f089		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f089					      REPEND
    121  f08b		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f08b					      REPEND
    121  f08d		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f08d					      REPEND
    121  f08f		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f08f					      REPEND
    121  f091		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    120  f091					      REPEND
    121  f093		       85 02		      sta	WSYNC	; display 33 lines of VBLANK
    122  f095					      REPEND
    123  f095
    124  f095							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    125  f095							;; Calculations performed in Pre-VBlank
    126  f095							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    127  f095
    128  f095		       a5 80		      lda	SnowmanX
    129  f097		       a0 00		      ldy	#0
    130  f099		       20 18 f2 	      jsr	SetObjectX	; set horizontal position for snowman and jump to subroutine
    131  f09c
    132  f09c		       a5 82		      lda	IcicleX
    133  f09e		       a0 01		      ldy	#1
    134  f0a0		       20 18 f2 	      jsr	SetObjectX	; set horizontal position for icicle and jump to subroutine
    135  f0a3
    136  f0a3		       20 4d f2 	      jsr	CalculateDigitOffset	; calculates the digit offset for lookup table
    137  f0a6
    138  f0a6		       85 02		      sta	WSYNC	; wait 1 scan line
    139  f0a8		       85 2a		      sta	HMOVE	; apply the offsets set by subroutine
    140  f0aa
    141  f0aa		       a9 00		      lda	#0
    142  f0ac		       85 01		      sta	VBLANK	; turns off VBLANK
    143  f0ae
    144  f0ae							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    145  f0ae							;; Render 192 visible scan lines
    146  f0ae							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    147  f0ae
    148  f0ae		       a9 00		      lda	#0
    149  f0b0		       85 0d		      sta	PF0
    150  f0b2		       85 0e		      sta	PF1
    151  f0b4		       85 0f		      sta	PF2
    152  f0b6		       85 1b		      sta	GRP0
    153  f0b8		       85 1c		      sta	GRP1	; resets registers before displaying the score
    154  f0ba		       85 0a		      sta	CTRLPF
    155  f0bc		       a9 0e		      lda	#$0e
    156  f0be		       85 09		      sta	COLUBK
    157  f0c0		       a9 9c		      lda	#$9c
    158  f0c2		       85 08		      sta	COLUPF
    159  f0c4		       a2 05		      ldx	#DIGITS_H	; X = Digits height
    160  f0c6
    161  f0c6				   .ScoreDigitLoop
    162  f0c6		       85 02		      sta	WSYNC	; wait for the end of scanline
    163  f0c8		       a4 8c		      ldy	TensDigit	; get the left digit offset for the Timer
    164  f0ca		       b9 6e f2 	      lda	Digits,Y	; load the digit pattern from lookup table
    165  f0cd		       29 f0		      and	#%11110000	; mask the graphics for the ones digit
    166  f0cf		       85 89		      sta	TimerSprite	; save the timer tens digit pattern in a variable
    167  f0d1
    168  f0d1		       a4 8a		      ldy	OnesDigit	; get the ones digit offset for the Timer
    169  f0d3		       b9 6e f2 	      lda	Digits,Y	; load digit pattern from the lookup table
    170  f0d6		       29 0f		      and	#%00001111	; mask the graphics for the tens digit
    171  f0d8		       05 89		      ora	TimerSprite	; merge with the saved tens digit graphics
    172  f0da		       85 89		      sta	TimerSprite	; and save it
    173  f0dc
    174  f0dc		       20 68 f2 	      jsr	Sleep12Cycles	; wastes some cycles
    175  f0df
    176  f0df		       85 0e		      sta	PF1	; update the playfield for Timer display
    177  f0e1
    178  f0e1		       85 02		      sta	WSYNC	; wait for next scanline
    179  f0e3		       e6 8c		      inc	TensDigit
    180  f0e5		       e6 8a		      inc	OnesDigit	; increment all digits for the next line of data
    181  f0e7
    182  f0e7		       20 68 f2 	      jsr	Sleep12Cycles	; waste some cycles
    183  f0ea
    184  f0ea		       ca		      dex		; X--
    185  f0eb		       85 0e		      sta	PF1	; update the playfield for the Timer display
    186  f0ed		       d0 d7		      bne	.ScoreDigitLoop	; if dex != 0, then branch to ScoreDigitLoop
    187  f0ef
    188  f0ef		       85 02		      sta	WSYNC
    189  f0f1
    190  f0f1		       a9 00		      lda	#0
    191  f0f3		       85 0d		      sta	PF0
    192  f0f5		       85 0e		      sta	PF1
    193  f0f7		       85 0f		      sta	PF2
    194  f0f9
    195  f0f9		       85 02		      sta	WSYNC
    196  f0fb		       85 02		      sta	WSYNC
    197  f0fd		       85 02		      sta	WSYNC
    198  f0ff
    199  f0ff
    200  f0ff				   VisibleLines
    201  f0ff		       a9 9e		      lda	#$9e
    202  f101		       85 08		      sta	COLUPF	; sets color of playfield to ice blue white
    203  f103		       a9 01		      lda	#%00000001
    204  f105		       85 0a		      sta	CTRLPF	; reflects playfield
    205  f107		       a9 f0		      lda	#$F0
    206  f109		       85 0d		      sta	PF0	; sets PF0 bit pattern
    207  f10b		       a9 fc		      lda	#$FC
    208  f10d		       85 0e		      sta	PF1	; sets PF1 bit pattern lda #0 sta PF2
    209  f10f		       a9 ae		      lda	#$ae
    210  f111		       85 09		      sta	COLUBK	; sets color to background light blue
    211  f113
    212  f113		       a2 55		      ldx	#85	; runs loop 79 times
    213  f115				   .MainLineLoop
    214  f115				   .InsideSnowman
    215  f115		       8a		      txa		; transfer X to accumulator
    216  f116		       38		      sec		; set carry
    217  f117		       e5 81		      sbc	SnowmanY	; subtrack left body Y position from accumulator
    218  f119		       c5 0a		      cmp	SNOWMAN_H	; inside sprite height bounds?
    219  f11b		       90 02		      bcc	.DrawSnowman	; if inside bounds, draw snowman sprite
    220  f11d		       a9 00		      lda	#0	; else set lookup to 0
    221  f11f
    222  f11f				   .DrawSnowman
    223  f11f		       18		      clc		; clear carry flag
    224  f120		       65 84		      adc	SnowmanOffsetL	; go to left sprite frame in memory
    225  f122		       18		      clc		; clear carry flag
    226  f123		       65 85		      adc	SnowmanOffsetR	; go to right sprite frame in memory
    227  f125		       a8		      tay		; load Y
    228  f126		       a9 05		      lda	#%00000101
    229  f128		       85 04		      sta	NUSIZ0
    230  f12a		       b1 90		      lda	(SnowmanPtr),Y	; load snowman from lookup table
    231  f12c		       85 02		      sta	WSYNC	; wait for scan line
    232  f12e		       85 1b		      sta	GRP0	; set graphics for player 0 (snowman)
    233  f130		       b1 8e		      lda	(SnowmanColPtr),Y	; load snowman color from lookup table
    234  f132		       85 06		      sta	COLUP0	; set color of player 0
    235  f134
    236  f134				   .InsideIcicle
    237  f134		       8a		      txa		; transfer X to accumulator
    238  f135		       38		      sec		; set carry
    239  f136		       e5 83		      sbc	IcicleY	; subtrack left body Y position from accumulator
    240  f138		       c5 0a		      cmp	ICICLE_H	; inside sprite height bounds?
    241  f13a		       90 02		      bcc	.DrawIcicle	; if inside bounds, draw icicle sprite
    242  f13c		       a9 00		      lda	#0	; else set lookup to 0
    243  f13e
    244  f13e				   .DrawIcicle
    245  f13e		       a8		      tay		; load Y
    246  f13f		       b1 94		      lda	(IciclePtr),Y	; load icicle from lookup table
    247  f141		       85 02		      sta	WSYNC	; wait for scan line
    248  f143		       85 1c		      sta	GRP1	; set graphics for player 1 (icicle)
    249  f145		       b1 92		      lda	(IcicleColPtr),Y	; load icicle color from lookup table
    250  f147		       85 07		      sta	COLUP1	; set color of player 1 (icicle)
    251  f149
    252  f149		       ca		      dex		; X--
    253  f14a		       d0 c9		      bne	.MainLineLoop	; While (X != 0)
    254  f14c
    255  f14c		       a9 00		      lda	#0
    256  f14e		       85 84		      sta	SnowmanOffsetL
    257  f150		       85 85		      sta	SnowmanOffsetR	; reset left and right offsets
    258  f152
    259  f152
    260  f152		       a9 0c		      lda	#$0c
    261  f154		       85 09		      sta	COLUBK	; sets color to background snow grey
    262  f156
    263  f156					      REPEAT	1
    264  f156		       85 02		      sta	WSYNC
    265  f158		       85 02		      sta	WSYNC
    266  f15a					      REPEND
    267  f15a
    268  f15a		       a9 0e		      lda	#$0e
    269  f15c		       85 09		      sta	COLUBK	; sets color to background snow white
    270  f15e
    271  f15e					      REPEAT	6
    272  f15e		       85 02		      sta	WSYNC
    273  f160		       85 02		      sta	WSYNC
    271  f160					      REPEND
    272  f162		       85 02		      sta	WSYNC
    273  f164		       85 02		      sta	WSYNC
    271  f164					      REPEND
    272  f166		       85 02		      sta	WSYNC
    273  f168		       85 02		      sta	WSYNC
    271  f168					      REPEND
    272  f16a		       85 02		      sta	WSYNC
    273  f16c		       85 02		      sta	WSYNC
    271  f16c					      REPEND
    272  f16e		       85 02		      sta	WSYNC
    273  f170		       85 02		      sta	WSYNC
    271  f170					      REPEND
    272  f172		       85 02		      sta	WSYNC
    273  f174		       85 02		      sta	WSYNC
    274  f176					      REPEND
    275  f176
    276  f176							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    277  f176							;; Display Overscan of 30 lines
    278  f176							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    279  f176
    280  f176		       a9 02		      lda	#2
    281  f178		       85 01		      sta	VBLANK	; turns on VBLANK
    282  f17a					      REPEAT	30
    283  f17a		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f17a					      REPEND
    283  f17c		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f17c					      REPEND
    283  f17e		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f17e					      REPEND
    283  f180		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f180					      REPEND
    283  f182		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f182					      REPEND
    283  f184		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f184					      REPEND
    283  f186		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f186					      REPEND
    283  f188		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f188					      REPEND
    283  f18a		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f18a					      REPEND
    283  f18c		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f18c					      REPEND
    283  f18e		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f18e					      REPEND
    283  f190		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f190					      REPEND
    283  f192		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f192					      REPEND
    283  f194		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f194					      REPEND
    283  f196		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f196					      REPEND
    283  f198		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f198					      REPEND
    283  f19a		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f19a					      REPEND
    283  f19c		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f19c					      REPEND
    283  f19e		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f19e					      REPEND
    283  f1a0		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f1a0					      REPEND
    283  f1a2		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f1a2					      REPEND
    283  f1a4		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f1a4					      REPEND
    283  f1a6		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f1a6					      REPEND
    283  f1a8		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f1a8					      REPEND
    283  f1aa		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f1aa					      REPEND
    283  f1ac		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f1ac					      REPEND
    283  f1ae		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f1ae					      REPEND
    283  f1b0		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f1b0					      REPEND
    283  f1b2		       85 02		      sta	WSYNC	; display 30 overscan lines
    282  f1b2					      REPEND
    283  f1b4		       85 02		      sta	WSYNC	; display 30 overscan lines
    284  f1b6					      REPEND
    285  f1b6
    286  f1b6		       a9 00		      lda	#0
    287  f1b8		       85 01		      sta	VBLANK	; turns off VBLANK
    288  f1ba
    289  f1ba							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    290  f1ba							;; Joystick input for Player 0 (snowman)
    291  f1ba							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    292  f1ba
    293  f1ba				   CheckLeft
    294  f1ba		       a9 40		      lda	#%01000000
    295  f1bc		       2c 80 02 	      bit	SWCHA	; check for left joystick input
    296  f1bf		       d0 16		      bne	CheckRight	; go to check right joystick input
    297  f1c1		       a5 0a		      lda	SNOWMAN_H
    298  f1c3		       85 84		      sta	SnowmanOffsetL	; adds height to go to left sprite frame
    299  f1c5					      REPEAT	2
    300  f1c5		       a5 80		      lda	SnowmanX
    301  f1c7		       18		      clc		; clears carry
    302  f1c8		       c9 1f		      cmp	#31	; compares Snowman X with value 31
    303  f1ca		       30 0b		      bmi	CheckRight	; goes to check right if less that 31
    304  f1cc		       c6 80		      dec	SnowmanX	; moves snowman left two pixels per frame
    299  f1cc					      REPEND
    300  f1ce		       a5 80		      lda	SnowmanX
    301  f1d0		       18		      clc		; clears carry
    302  f1d1		       c9 1f		      cmp	#31	; compares Snowman X with value 31
    303  f1d3		       30 02		      bmi	CheckRight	; goes to check right if less that 31
    304  f1d5		       c6 80		      dec	SnowmanX	; moves snowman left two pixels per frame
    305  f1d7					      REPEND
    306  f1d7
    307  f1d7				   CheckRight
    308  f1d7		       a9 80		      lda	#%10000000
    309  f1d9		       2c 80 02 	      bit	SWCHA	; check for right joystick input
    310  f1dc		       d0 16		      bne	EndJoystickTest	; ends test if not right either
    311  f1de		       a5 14		      lda	SNOWMAN_H_X2
    312  f1e0		       85 84		      sta	SnowmanOffsetL	; adds height x 2 to go to right sprite frame
    313  f1e2					      REPEAT	2
    314  f1e2		       a5 80		      lda	SnowmanX
    315  f1e4		       18		      clc		; clears carry
    316  f1e5		       c9 5e		      cmp	#94	; compares Snowman X with value 94
    317  f1e7		       10 0b		      bpl	EndJoystickTest	; goes to ends test if value > 94
    318  f1e9		       e6 80		      inc	SnowmanX	; moves snowman right two pixels per frame
    313  f1e9					      REPEND
    314  f1eb		       a5 80		      lda	SnowmanX
    315  f1ed		       18		      clc		; clears carry
    316  f1ee		       c9 5e		      cmp	#94	; compares Snowman X with value 94
    317  f1f0		       10 02		      bpl	EndJoystickTest	; goes to ends test if value > 94
    318  f1f2		       e6 80		      inc	SnowmanX	; moves snowman right two pixels per frame
    319  f1f4					      REPEND
    320  f1f4
    321  f1f4				   EndJoystickTest		; if no joystick input is detected, do nothing
    322  f1f4
    323  f1f4							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    324  f1f4							;; Updates positions for next frame
    325  f1f4							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    326  f1f4
    327  f1f4				   UpdateIciclePos
    328  f1f4		       a5 83		      lda	IcicleY
    329  f1f6		       18		      clc		; clears carry
    330  f1f7		       c9 02		      cmp	#2	; compares with value 2
    331  f1f9		       30 09		      bmi	.ResetIciclePos	; if icicle is less than 2 (icicle hit floor) reset position
    332  f1fb					      REPEAT	3
    333  f1fb		       c6 83		      dec	IcicleY	; moves icicle down at speed of 3px per frame
    332  f1fb					      REPEND
    333  f1fd		       c6 83		      dec	IcicleY	; moves icicle down at speed of 3px per frame
    332  f1fd					      REPEND
    333  f1ff		       c6 83		      dec	IcicleY	; moves icicle down at speed of 3px per frame
    334  f201					      REPEND
    335  f201		       4c 07 f2 	      jmp	EndIciclePosUpdate
    336  f204
    337  f204				   .ResetIciclePos
    338  f204		       20 2c f2 	      jsr	GetRandomIciclePos	; cals subrouting for random pos for icicle
    339  f207
    340  f207				   EndIciclePosUpdate		; does nothing if it does not reset
    341  f207
    342  f207							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    343  f207							;; Check for collision between player 0 (snowman) and player 1 (
    344  f207							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    345  f207
    346  f207				   CheckCollision
    347  f207		       a9 80		      lda	#%10000000	; CXPPMM bit 7 (detects P0 and P1 colission)
    348  f209		       24 07		      bit	CXPPMM	; check for collision
    349  f20b		       d0 03		      bne	.Collision	; branches if collision occured
    350  f20d		       4c 13 f2 	      jmp	EndCollisionCheck	; skip if no collision
    351  f210
    352  f210				   .Collision
    353  f210		       20 69 f2 	      jsr	GameOver	; calls GameOver subroutine
    354  f213
    355  f213				   EndCollisionCheck		; fallback for no collision
    356  f213		       85 2c		      sta	CXCLR	; clears collision flags
    357  f215
    358  f215							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    359  f215							;; Loop back to the Start
    360  f215							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    361  f215
    362  f215		       4c 43 f0 	      jmp	StartFrame	; continue to next frame
    363  f218
    364  f218							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    365  f218							;; Subroutine to handle horizontal positioning
    366  f218							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    367  f218
    368  f218				   SetObjectX subroutine
    369  f218		       85 02		      sta	WSYNC	; start a fresh scanline
    370  f21a		       38		      sec		; set carry flag
    371  f21b				   .Div15Loop
    372  f21b		       e9 0f		      sbc	#15	; subtract 15 from accumulator
    373  f21d		       b0 fc		      bcs	.Div15Loop	; loop until flag is clear
    374  f21f		       49 07		      eor	#%00000111	; XOR with 4 bits for (-8 to 7) offset
    375  f221					      REPEAT	4
    376  f221		       0a		      asl		; shift left 4 time to correct 4 bits
    375  f221					      REPEND
    376  f222		       0a		      asl		; shift left 4 time to correct 4 bits
    375  f222					      REPEND
    376  f223		       0a		      asl		; shift left 4 time to correct 4 bits
    375  f223					      REPEND
    376  f224		       0a		      asl		; shift left 4 time to correct 4 bits
    377  f225					      REPEND
    378  f225		       99 20 00 	      sta	HMP0,Y	; store the fine offset
    379  f228		       99 10 00 	      sta	RESP0,Y	; fix object in 15-step increment
    380  f22b		       60		      rts
    381  f22c
    382  f22c							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    383  f22c							;; Subroutine to get random X position for icicle
    384  f22c							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    385  f22c
    386  f22c				   GetRandomIciclePos subroutine
    387  f22c		       a5 86		      lda	Random
    388  f22e		       0a		      asl
    389  f22f		       45 86		      eor	Random
    390  f231		       0a		      asl
    391  f232		       45 86		      eor	Random
    392  f234		       0a		      asl
    393  f235		       0a		      asl
    394  f236		       45 86		      eor	Random
    395  f238		       0a		      asl
    396  f239		       26 86		      rol	Random	; Performs bit operations for random number
    397  f23b
    398  f23b		       4a		      lsr
    399  f23c		       4a		      lsr		; divides value by 4
    400  f23d		       85 82		      sta	IcicleX	; stores value in IcicleX
    401  f23f		       a9 1e		      lda	#30
    402  f241		       18		      clc		; clears the carry
    403  f242		       65 82		      adc	IcicleX
    404  f244		       85 82		      sta	IcicleX	; IcicleX += 30
    405  f246		       a9 49		      lda	#73
    406  f248		       85 83		      sta	IcicleY	; IcicleY = 73
    407  f24a		       e6 87		      inc	Score	; Increments score
    408  f24c		       60		      rts		; return
    409  f24d
    410  f24d							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    411  f24d							;; Subroutine to get time digit offsets
    412  f24d							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    413  f24d
    414  f24d				   CalculateDigitOffset subroutine
    415  f24d		       a5 87		      lda	Score
    416  f24f		       29 0f		      and	#%00001111	; masks first 4 bits
    417  f251		       85 88		      sta	Temp	; save A in Temp
    418  f253		       0a		      asl
    419  f254		       0a		      asl		; shift left twice for n * 4
    420  f255		       65 88		      adc	Temp	; adds original A for n * 5
    421  f257		       85 8a		      sta	OnesDigit	; stores ones digit
    422  f259
    423  f259		       a5 87		      lda	Score
    424  f25b		       29 f0		      and	#%11110000	; masks last 4 bits
    425  f25d		       4a		      lsr
    426  f25e		       4a		      lsr		; shift right twice for n / 4
    427  f25f		       85 88		      sta	Temp	; save A in Temp
    428  f261		       4a		      lsr
    429  f262		       4a		      lsr		; shift right twice for n / 16
    430  f263		       65 88		      adc	Temp	; adds value stored in temp for n / 16 + n / 4
    431  f265		       85 8c		      sta	TensDigit	; stores tens digit
    432  f267		       60		      rts		; return
    433  f268
    434  f268							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    435  f268							;; Subroutine to waste 12 cycles
    436  f268							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    437  f268				   Sleep12Cycles subroutine
    438  f268		       60		      rts
    439  f269
    440  f269							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    441  f269							;; Subroutine when game is over (collision occured)
    442  f269							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    443  f269
    444  f269				   GameOver   subroutine
    445  f269
    446  f269		       a9 00		      lda	#0
    447  f26b		       85 87		      sta	Score	; score gets reset
    448  f26d		       60		      rts		; return
    449  f26e
    450  f26e							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    451  f26e							;; Lookup Table
    452  f26e							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    453  f26e
    454  f26e				   Digits
    455  f26e		       77		      .byte.b	%01110111	; ### ###
    456  f26f		       55		      .byte.b	%01010101	; # # # #
    457  f270		       55		      .byte.b	%01010101	; # # # #
    458  f271		       55		      .byte.b	%01010101	; # # # #
    459  f272		       77		      .byte.b	%01110111	; ### ###
    460  f273
    461  f273		       11		      .byte.b	%00010001	;   #	 #
    462  f274		       11		      .byte.b	%00010001	;   #	 #
    463  f275		       11		      .byte.b	%00010001	;   #	 #
    464  f276		       11		      .byte.b	%00010001	;   #	 #
    465  f277		       11		      .byte.b	%00010001	;   #	 #
    466  f278
    467  f278		       77		      .byte.b	%01110111	; ### ###
    468  f279		       11		      .byte.b	%00010001	;   #	 #
    469  f27a		       77		      .byte.b	%01110111	; ### ###
    470  f27b		       44		      .byte.b	%01000100	; #   #
    471  f27c		       77		      .byte.b	%01110111	; ### ###
    472  f27d
    473  f27d		       77		      .byte.b	%01110111	; ### ###
    474  f27e		       11		      .byte.b	%00010001	;   #	 #
    475  f27f		       33		      .byte.b	%00110011	;  ##	##
    476  f280		       11		      .byte.b	%00010001	;   #	 #
    477  f281		       77		      .byte.b	%01110111	; ### ###
    478  f282
    479  f282		       55		      .byte.b	%01010101	; # # # #
    480  f283		       55		      .byte.b	%01010101	; # # # #
    481  f284		       77		      .byte.b	%01110111	; ### ###
    482  f285		       11		      .byte.b	%00010001	;   #	 #
    483  f286		       11		      .byte.b	%00010001	;   #	 #
    484  f287
    485  f287		       77		      .byte.b	%01110111	; ### ###
    486  f288		       44		      .byte.b	%01000100	; #   #
    487  f289		       77		      .byte.b	%01110111	; ### ###
    488  f28a		       11		      .byte.b	%00010001	;   #	 #
    489  f28b		       77		      .byte.b	%01110111	; ### ###
    490  f28c
    491  f28c		       77		      .byte.b	%01110111	; ### ###
    492  f28d		       44		      .byte.b	%01000100	; #   #
    493  f28e		       77		      .byte.b	%01110111	; ### ###
    494  f28f		       55		      .byte.b	%01010101	; # # # #
    495  f290		       77		      .byte.b	%01110111	; ### ###
    496  f291
    497  f291		       77		      .byte.b	%01110111	; ### ###
    498  f292		       11		      .byte.b	%00010001	;   #	 #
    499  f293		       11		      .byte.b	%00010001	;   #	 #
    500  f294		       11		      .byte.b	%00010001	;   #	 #
    501  f295		       11		      .byte.b	%00010001	;   #	 #
    502  f296
    503  f296		       77		      .byte.b	%01110111	; ### ###
    504  f297		       55		      .byte.b	%01010101	; # # # #
    505  f298		       77		      .byte.b	%01110111	; ### ###
    506  f299		       55		      .byte.b	%01010101	; # # # #
    507  f29a		       77		      .byte.b	%01110111	; ### ###
    508  f29b
    509  f29b		       77		      .byte.b	%01110111	; ### ###
    510  f29c		       55		      .byte.b	%01010101	; # # # #
    511  f29d		       77		      .byte.b	%01110111	; ### ###
    512  f29e		       11		      .byte.b	%00010001	;   #	 #
    513  f29f		       77		      .byte.b	%01110111	; ### ###
    514  f2a0
    515  f2a0		       22		      .byte.b	%00100010	;  #	#
    516  f2a1		       55		      .byte.b	%01010101	; # # # #
    517  f2a2		       77		      .byte.b	%01110111	; ### ###
    518  f2a3		       55		      .byte.b	%01010101	; # # # #
    519  f2a4		       55		      .byte.b	%01010101	; # # # #
    520  f2a5
    521  f2a5		       77		      .byte.b	%01110111	; ### ###
    522  f2a6		       55		      .byte.b	%01010101	; # # # #
    523  f2a7		       66		      .byte.b	%01100110	; ##  ##
    524  f2a8		       55		      .byte.b	%01010101	; # # # #
    525  f2a9		       77		      .byte.b	%01110111	; ### ###
    526  f2aa
    527  f2aa		       77		      .byte.b	%01110111	; ### ###
    528  f2ab		       44		      .byte.b	%01000100	; #   #
    529  f2ac		       44		      .byte.b	%01000100	; #   #
    530  f2ad		       44		      .byte.b	%01000100	; #   #
    531  f2ae		       77		      .byte.b	%01110111	; ### ###
    532  f2af
    533  f2af		       66		      .byte.b	%01100110	; ##  ##
    534  f2b0		       55		      .byte.b	%01010101	; # # # #
    535  f2b1		       55		      .byte.b	%01010101	; # # # #
    536  f2b2		       55		      .byte.b	%01010101	; # # # #
    537  f2b3		       66		      .byte.b	%01100110	; ##  ##
    538  f2b4
    539  f2b4		       77		      .byte.b	%01110111	; ### ###
    540  f2b5		       44		      .byte.b	%01000100	; #   #
    541  f2b6		       77		      .byte.b	%01110111	; ### ###
    542  f2b7		       44		      .byte.b	%01000100	; #   #
    543  f2b8		       77		      .byte.b	%01110111	; ### ###
    544  f2b9
    545  f2b9		       77		      .byte.b	%01110111	; ### ###
    546  f2ba		       44		      .byte.b	%01000100	; #   #
    547  f2bb		       66		      .byte.b	%01100110	; ##  ##
    548  f2bc		       44		      .byte.b	%01000100	; #   #
    549  f2bd		       44		      .byte.b	%01000100	; #   #
    550  f2be
    551  f2be
    552  f2be				   SnowmanColor 		; color for snowman
    553  f2be		       00		      .byte.b	#$00
    554  f2bf		       0e		      .byte.b	#$0e
    555  f2c0		       0e		      .byte.b	#$0e
    556  f2c1		       0e		      .byte.b	#$0e
    557  f2c2		       0e		      .byte.b	#$0e
    558  f2c3		       0e		      .byte.b	#$0e
    559  f2c4		       0e		      .byte.b	#$0e
    560  f2c5		       0e		      .byte.b	#$0e
    561  f2c6		       0e		      .byte.b	#$0e
    562  f2c7		       0e		      .byte.b	#$0e
    563  f2c8
    564  f2c8				   SnowmanColorLeft		; color for snowman when moving left
    565  f2c8		       00		      .byte.b	#$00
    566  f2c9		       0e		      .byte.b	#$0e
    567  f2ca		       0e		      .byte.b	#$0e
    568  f2cb		       0e		      .byte.b	#$0e
    569  f2cc		       0e		      .byte.b	#$0e
    570  f2cd		       0e		      .byte.b	#$0e
    571  f2ce		       0e		      .byte.b	#$0e
    572  f2cf		       0e		      .byte.b	#$0e
    573  f2d0		       0e		      .byte.b	#$0e
    574  f2d1		       0e		      .byte.b	#$0e
    575  f2d2
    576  f2d2				   SnowmanColor3		; color for snowman when moving right
    577  f2d2		       00		      .byte.b	#$00
    578  f2d3		       0e		      .byte.b	#$0e
    579  f2d4		       0e		      .byte.b	#$0e
    580  f2d5		       0e		      .byte.b	#$0e
    581  f2d6		       0e		      .byte.b	#$0e
    582  f2d7		       0e		      .byte.b	#$0e
    583  f2d8		       0e		      .byte.b	#$0e
    584  f2d9		       0e		      .byte.b	#$0e
    585  f2da		       0e		      .byte.b	#$0e
    586  f2db		       0e		      .byte.b	#$0e
    587  f2dc
    588  f2dc				   IcicleColor		; color for icicle
    589  f2dc		       00		      .byte.b	#%00
    590  f2dd		       9c		      .byte.b	#$9c
    591  f2de		       9c		      .byte.b	#$9c
    592  f2df		       9c		      .byte.b	#$9c
    593  f2e0		       9c		      .byte.b	#$9c
    594  f2e1		       9c		      .byte.b	#$9c
    595  f2e2		       9c		      .byte.b	#$9c
    596  f2e3		       9c		      .byte.b	#$9c
    597  f2e4		       9c		      .byte.b	#$9c
    598  f2e5		       9c		      .byte.b	#$9c
    599  f2e6
    600  f2e6				   Snowman
    601  f2e6		       00		      .byte.b	#%00000000
    602  f2e7		       ff		      .byte.b	#%11111111
    603  f2e8		       f7		      .byte.b	#%11110111
    604  f2e9		       ff		      .byte.b	#%11111111
    605  f2ea		       76		      .byte.b	#%01110110
    606  f2eb		       ff		      .byte.b	#%11111111
    607  f2ec		       a5		      .byte.b	#%10100101
    608  f2ed		       a5		      .byte.b	#%10100101
    609  f2ee		       5a		      .byte.b	#%01011010
    610  f2ef		       7e		      .byte.b	#%01111110
    611  f2f0
    612  f2f0				   SnowmanLeft
    613  f2f0		       00		      .byte.b	#%00000000
    614  f2f1		       3f		      .byte.b	#%00111111
    615  f2f2		       3c		      .byte.b	#%00111100
    616  f2f3		       3c		      .byte.b	#%00111100
    617  f2f4		       3d		      .byte.b	#%00111101
    618  f2f5		       ff		      .byte.b	#%11111111
    619  f2f6		       bc		      .byte.b	#%10111100
    620  f2f7		       3c		      .byte.b	#%00111100
    621  f2f8		       2c		      .byte.b	#%00101100
    622  f2f9		       3c		      .byte.b	#%00111100
    623  f2fa
    624  f2fa				   SnowmanRight
    625  f2fa		       00		      .byte.b	#%00000000
    626  f2fb		       fc		      .byte.b	#%11111100
    627  f2fc		       3c		      .byte.b	#%00111100
    628  f2fd		       3c		      .byte.b	#%00111100
    629  f2fe		       bc		      .byte.b	#%10111100
    630  f2ff		       ff		      .byte.b	#%11111111
    631  f300		       3d		      .byte.b	#%00111101
    632  f301		       3c		      .byte.b	#%00111100
    633  f302		       34		      .byte.b	#%00110100
    634  f303		       3c		      .byte.b	#%00111100
    635  f304
    636  f304				   Icicle		; outline of icicle
    637  f304		       00		      .byte.b	#%00000000
    638  f305		       08		      .byte.b	#%00001000
    639  f306		       08		      .byte.b	#%00001000
    640  f307		       18		      .byte.b	#%00011000
    641  f308		       18		      .byte.b	#%00011000
    642  f309		       18		      .byte.b	#%00011000
    643  f30a		       1c		      .byte.b	#%00011100
    644  f30b		       1c		      .byte.b	#%00011100
    645  f30c		       1c		      .byte.b	#%00011100
    646  f30d		       3c		      .byte.b	#%00111100
    647  f30e
    648  f30e							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    649  f30e							;; Fill ROM with 4KB
    650  f30e							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    651  f30e
    652  fffc					      org	$FFFC	; moves to $FFFC
    653  fffc		       00 f0		      word.w	Reset	; write 2 bytes with reset
    654  fffe		       00 f0		      word.w	Reset	; write 2 bytes with interuption vector
